// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.2
// source: nodeapi.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	NodeAPI_BucketCreate_FullMethodName = "/nodeapi.NodeAPI/BucketCreate"
	NodeAPI_BucketView_FullMethodName   = "/nodeapi.NodeAPI/BucketView"
	NodeAPI_BucketList_FullMethodName   = "/nodeapi.NodeAPI/BucketList"
	NodeAPI_BucketDelete_FullMethodName = "/nodeapi.NodeAPI/BucketDelete"
)

// NodeAPIClient is the client API for NodeAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeAPIClient interface {
	// Bucket APIs.
	BucketCreate(ctx context.Context, in *BucketCreateRequest, opts ...grpc.CallOption) (*BucketCreateResponse, error)
	BucketView(ctx context.Context, in *BucketViewRequest, opts ...grpc.CallOption) (*BucketViewResponse, error)
	BucketList(ctx context.Context, in *BucketListRequest, opts ...grpc.CallOption) (*BucketListResponse, error)
	BucketDelete(ctx context.Context, in *BucketDeleteRequest, opts ...grpc.CallOption) (*BucketDeleteResponse, error)
}

type nodeAPIClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeAPIClient(cc grpc.ClientConnInterface) NodeAPIClient {
	return &nodeAPIClient{cc}
}

func (c *nodeAPIClient) BucketCreate(ctx context.Context, in *BucketCreateRequest, opts ...grpc.CallOption) (*BucketCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BucketCreateResponse)
	err := c.cc.Invoke(ctx, NodeAPI_BucketCreate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeAPIClient) BucketView(ctx context.Context, in *BucketViewRequest, opts ...grpc.CallOption) (*BucketViewResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BucketViewResponse)
	err := c.cc.Invoke(ctx, NodeAPI_BucketView_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeAPIClient) BucketList(ctx context.Context, in *BucketListRequest, opts ...grpc.CallOption) (*BucketListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BucketListResponse)
	err := c.cc.Invoke(ctx, NodeAPI_BucketList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeAPIClient) BucketDelete(ctx context.Context, in *BucketDeleteRequest, opts ...grpc.CallOption) (*BucketDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BucketDeleteResponse)
	err := c.cc.Invoke(ctx, NodeAPI_BucketDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeAPIServer is the server API for NodeAPI service.
// All implementations must embed UnimplementedNodeAPIServer
// for forward compatibility.
type NodeAPIServer interface {
	// Bucket APIs.
	BucketCreate(context.Context, *BucketCreateRequest) (*BucketCreateResponse, error)
	BucketView(context.Context, *BucketViewRequest) (*BucketViewResponse, error)
	BucketList(context.Context, *BucketListRequest) (*BucketListResponse, error)
	BucketDelete(context.Context, *BucketDeleteRequest) (*BucketDeleteResponse, error)
	mustEmbedUnimplementedNodeAPIServer()
}

// UnimplementedNodeAPIServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNodeAPIServer struct{}

func (UnimplementedNodeAPIServer) BucketCreate(context.Context, *BucketCreateRequest) (*BucketCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BucketCreate not implemented")
}
func (UnimplementedNodeAPIServer) BucketView(context.Context, *BucketViewRequest) (*BucketViewResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BucketView not implemented")
}
func (UnimplementedNodeAPIServer) BucketList(context.Context, *BucketListRequest) (*BucketListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BucketList not implemented")
}
func (UnimplementedNodeAPIServer) BucketDelete(context.Context, *BucketDeleteRequest) (*BucketDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BucketDelete not implemented")
}
func (UnimplementedNodeAPIServer) mustEmbedUnimplementedNodeAPIServer() {}
func (UnimplementedNodeAPIServer) testEmbeddedByValue()                 {}

// UnsafeNodeAPIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeAPIServer will
// result in compilation errors.
type UnsafeNodeAPIServer interface {
	mustEmbedUnimplementedNodeAPIServer()
}

func RegisterNodeAPIServer(s grpc.ServiceRegistrar, srv NodeAPIServer) {
	// If the following call pancis, it indicates UnimplementedNodeAPIServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NodeAPI_ServiceDesc, srv)
}

func _NodeAPI_BucketCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BucketCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeAPIServer).BucketCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeAPI_BucketCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeAPIServer).BucketCreate(ctx, req.(*BucketCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeAPI_BucketView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BucketViewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeAPIServer).BucketView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeAPI_BucketView_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeAPIServer).BucketView(ctx, req.(*BucketViewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeAPI_BucketList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BucketListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeAPIServer).BucketList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeAPI_BucketList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeAPIServer).BucketList(ctx, req.(*BucketListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeAPI_BucketDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BucketDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeAPIServer).BucketDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeAPI_BucketDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeAPIServer).BucketDelete(ctx, req.(*BucketDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeAPI_ServiceDesc is the grpc.ServiceDesc for NodeAPI service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeAPI_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nodeapi.NodeAPI",
	HandlerType: (*NodeAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BucketCreate",
			Handler:    _NodeAPI_BucketCreate_Handler,
		},
		{
			MethodName: "BucketView",
			Handler:    _NodeAPI_BucketView_Handler,
		},
		{
			MethodName: "BucketList",
			Handler:    _NodeAPI_BucketList_Handler,
		},
		{
			MethodName: "BucketDelete",
			Handler:    _NodeAPI_BucketDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nodeapi.proto",
}

const (
	StreamAPI_FileUploadCreate_FullMethodName          = "/nodeapi.StreamAPI/FileUploadCreate"
	StreamAPI_FileUploadChunkCreate_FullMethodName     = "/nodeapi.StreamAPI/FileUploadChunkCreate"
	StreamAPI_FileUploadBlock_FullMethodName           = "/nodeapi.StreamAPI/FileUploadBlock"
	StreamAPI_FileUploadCommit_FullMethodName          = "/nodeapi.StreamAPI/FileUploadCommit"
	StreamAPI_FileDownloadCreate_FullMethodName        = "/nodeapi.StreamAPI/FileDownloadCreate"
	StreamAPI_FileDownloadRangeCreate_FullMethodName   = "/nodeapi.StreamAPI/FileDownloadRangeCreate"
	StreamAPI_FileDownloadChunkCreate_FullMethodName   = "/nodeapi.StreamAPI/FileDownloadChunkCreate"
	StreamAPI_FileDownloadChunkCreateV2_FullMethodName = "/nodeapi.StreamAPI/FileDownloadChunkCreateV2"
	StreamAPI_FileDownloadBlock_FullMethodName         = "/nodeapi.StreamAPI/FileDownloadBlock"
	StreamAPI_FileList_FullMethodName                  = "/nodeapi.StreamAPI/FileList"
	StreamAPI_FileView_FullMethodName                  = "/nodeapi.StreamAPI/FileView"
	StreamAPI_FileVersions_FullMethodName              = "/nodeapi.StreamAPI/FileVersions"
	StreamAPI_FileDelete_FullMethodName                = "/nodeapi.StreamAPI/FileDelete"
)

// StreamAPIClient is the client API for StreamAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Stream APIs.
type StreamAPIClient interface {
	FileUploadCreate(ctx context.Context, in *StreamFileUploadCreateRequest, opts ...grpc.CallOption) (*StreamFileUploadCreateResponse, error)
	FileUploadChunkCreate(ctx context.Context, in *StreamFileUploadChunkCreateRequest, opts ...grpc.CallOption) (*StreamFileUploadChunkCreateResponse, error)
	FileUploadBlock(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[StreamFileBlockData, StreamFileUploadBlockResponse], error)
	FileUploadCommit(ctx context.Context, in *StreamFileUploadCommitRequest, opts ...grpc.CallOption) (*StreamFileUploadCommitResponse, error)
	FileDownloadCreate(ctx context.Context, in *StreamFileDownloadCreateRequest, opts ...grpc.CallOption) (*StreamFileDownloadCreateResponse, error)
	FileDownloadRangeCreate(ctx context.Context, in *StreamFileDownloadRangeCreateRequest, opts ...grpc.CallOption) (*StreamFileDownloadCreateResponse, error)
	FileDownloadChunkCreate(ctx context.Context, in *StreamFileDownloadChunkCreateRequest, opts ...grpc.CallOption) (*StreamFileDownloadChunkCreateResponse, error)
	FileDownloadChunkCreateV2(ctx context.Context, in *StreamFileDownloadChunkCreateRequest, opts ...grpc.CallOption) (*StreamFileDownloadChunkCreateResponseV2, error)
	FileDownloadBlock(ctx context.Context, in *StreamFileDownloadBlockRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamFileBlockData], error)
	FileList(ctx context.Context, in *StreamFileListRequest, opts ...grpc.CallOption) (*StreamFileListResponse, error)
	FileView(ctx context.Context, in *StreamFileViewRequest, opts ...grpc.CallOption) (*StreamFileViewResponse, error)
	FileVersions(ctx context.Context, in *StreamFileListVersionsRequest, opts ...grpc.CallOption) (*StreamFileListVersionsResponse, error)
	FileDelete(ctx context.Context, in *StreamFileDeleteRequest, opts ...grpc.CallOption) (*StreamFileDeleteResponse, error)
}

type streamAPIClient struct {
	cc grpc.ClientConnInterface
}

func NewStreamAPIClient(cc grpc.ClientConnInterface) StreamAPIClient {
	return &streamAPIClient{cc}
}

func (c *streamAPIClient) FileUploadCreate(ctx context.Context, in *StreamFileUploadCreateRequest, opts ...grpc.CallOption) (*StreamFileUploadCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamFileUploadCreateResponse)
	err := c.cc.Invoke(ctx, StreamAPI_FileUploadCreate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamAPIClient) FileUploadChunkCreate(ctx context.Context, in *StreamFileUploadChunkCreateRequest, opts ...grpc.CallOption) (*StreamFileUploadChunkCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamFileUploadChunkCreateResponse)
	err := c.cc.Invoke(ctx, StreamAPI_FileUploadChunkCreate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamAPIClient) FileUploadBlock(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[StreamFileBlockData, StreamFileUploadBlockResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &StreamAPI_ServiceDesc.Streams[0], StreamAPI_FileUploadBlock_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamFileBlockData, StreamFileUploadBlockResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StreamAPI_FileUploadBlockClient = grpc.ClientStreamingClient[StreamFileBlockData, StreamFileUploadBlockResponse]

func (c *streamAPIClient) FileUploadCommit(ctx context.Context, in *StreamFileUploadCommitRequest, opts ...grpc.CallOption) (*StreamFileUploadCommitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamFileUploadCommitResponse)
	err := c.cc.Invoke(ctx, StreamAPI_FileUploadCommit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamAPIClient) FileDownloadCreate(ctx context.Context, in *StreamFileDownloadCreateRequest, opts ...grpc.CallOption) (*StreamFileDownloadCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamFileDownloadCreateResponse)
	err := c.cc.Invoke(ctx, StreamAPI_FileDownloadCreate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamAPIClient) FileDownloadRangeCreate(ctx context.Context, in *StreamFileDownloadRangeCreateRequest, opts ...grpc.CallOption) (*StreamFileDownloadCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamFileDownloadCreateResponse)
	err := c.cc.Invoke(ctx, StreamAPI_FileDownloadRangeCreate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamAPIClient) FileDownloadChunkCreate(ctx context.Context, in *StreamFileDownloadChunkCreateRequest, opts ...grpc.CallOption) (*StreamFileDownloadChunkCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamFileDownloadChunkCreateResponse)
	err := c.cc.Invoke(ctx, StreamAPI_FileDownloadChunkCreate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamAPIClient) FileDownloadChunkCreateV2(ctx context.Context, in *StreamFileDownloadChunkCreateRequest, opts ...grpc.CallOption) (*StreamFileDownloadChunkCreateResponseV2, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamFileDownloadChunkCreateResponseV2)
	err := c.cc.Invoke(ctx, StreamAPI_FileDownloadChunkCreateV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamAPIClient) FileDownloadBlock(ctx context.Context, in *StreamFileDownloadBlockRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamFileBlockData], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &StreamAPI_ServiceDesc.Streams[1], StreamAPI_FileDownloadBlock_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamFileDownloadBlockRequest, StreamFileBlockData]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StreamAPI_FileDownloadBlockClient = grpc.ServerStreamingClient[StreamFileBlockData]

func (c *streamAPIClient) FileList(ctx context.Context, in *StreamFileListRequest, opts ...grpc.CallOption) (*StreamFileListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamFileListResponse)
	err := c.cc.Invoke(ctx, StreamAPI_FileList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamAPIClient) FileView(ctx context.Context, in *StreamFileViewRequest, opts ...grpc.CallOption) (*StreamFileViewResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamFileViewResponse)
	err := c.cc.Invoke(ctx, StreamAPI_FileView_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamAPIClient) FileVersions(ctx context.Context, in *StreamFileListVersionsRequest, opts ...grpc.CallOption) (*StreamFileListVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamFileListVersionsResponse)
	err := c.cc.Invoke(ctx, StreamAPI_FileVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamAPIClient) FileDelete(ctx context.Context, in *StreamFileDeleteRequest, opts ...grpc.CallOption) (*StreamFileDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamFileDeleteResponse)
	err := c.cc.Invoke(ctx, StreamAPI_FileDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StreamAPIServer is the server API for StreamAPI service.
// All implementations must embed UnimplementedStreamAPIServer
// for forward compatibility.
//
// Stream APIs.
type StreamAPIServer interface {
	FileUploadCreate(context.Context, *StreamFileUploadCreateRequest) (*StreamFileUploadCreateResponse, error)
	FileUploadChunkCreate(context.Context, *StreamFileUploadChunkCreateRequest) (*StreamFileUploadChunkCreateResponse, error)
	FileUploadBlock(grpc.ClientStreamingServer[StreamFileBlockData, StreamFileUploadBlockResponse]) error
	FileUploadCommit(context.Context, *StreamFileUploadCommitRequest) (*StreamFileUploadCommitResponse, error)
	FileDownloadCreate(context.Context, *StreamFileDownloadCreateRequest) (*StreamFileDownloadCreateResponse, error)
	FileDownloadRangeCreate(context.Context, *StreamFileDownloadRangeCreateRequest) (*StreamFileDownloadCreateResponse, error)
	FileDownloadChunkCreate(context.Context, *StreamFileDownloadChunkCreateRequest) (*StreamFileDownloadChunkCreateResponse, error)
	FileDownloadChunkCreateV2(context.Context, *StreamFileDownloadChunkCreateRequest) (*StreamFileDownloadChunkCreateResponseV2, error)
	FileDownloadBlock(*StreamFileDownloadBlockRequest, grpc.ServerStreamingServer[StreamFileBlockData]) error
	FileList(context.Context, *StreamFileListRequest) (*StreamFileListResponse, error)
	FileView(context.Context, *StreamFileViewRequest) (*StreamFileViewResponse, error)
	FileVersions(context.Context, *StreamFileListVersionsRequest) (*StreamFileListVersionsResponse, error)
	FileDelete(context.Context, *StreamFileDeleteRequest) (*StreamFileDeleteResponse, error)
	mustEmbedUnimplementedStreamAPIServer()
}

// UnimplementedStreamAPIServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStreamAPIServer struct{}

func (UnimplementedStreamAPIServer) FileUploadCreate(context.Context, *StreamFileUploadCreateRequest) (*StreamFileUploadCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FileUploadCreate not implemented")
}
func (UnimplementedStreamAPIServer) FileUploadChunkCreate(context.Context, *StreamFileUploadChunkCreateRequest) (*StreamFileUploadChunkCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FileUploadChunkCreate not implemented")
}
func (UnimplementedStreamAPIServer) FileUploadBlock(grpc.ClientStreamingServer[StreamFileBlockData, StreamFileUploadBlockResponse]) error {
	return status.Errorf(codes.Unimplemented, "method FileUploadBlock not implemented")
}
func (UnimplementedStreamAPIServer) FileUploadCommit(context.Context, *StreamFileUploadCommitRequest) (*StreamFileUploadCommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FileUploadCommit not implemented")
}
func (UnimplementedStreamAPIServer) FileDownloadCreate(context.Context, *StreamFileDownloadCreateRequest) (*StreamFileDownloadCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FileDownloadCreate not implemented")
}
func (UnimplementedStreamAPIServer) FileDownloadRangeCreate(context.Context, *StreamFileDownloadRangeCreateRequest) (*StreamFileDownloadCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FileDownloadRangeCreate not implemented")
}
func (UnimplementedStreamAPIServer) FileDownloadChunkCreate(context.Context, *StreamFileDownloadChunkCreateRequest) (*StreamFileDownloadChunkCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FileDownloadChunkCreate not implemented")
}
func (UnimplementedStreamAPIServer) FileDownloadChunkCreateV2(context.Context, *StreamFileDownloadChunkCreateRequest) (*StreamFileDownloadChunkCreateResponseV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FileDownloadChunkCreateV2 not implemented")
}
func (UnimplementedStreamAPIServer) FileDownloadBlock(*StreamFileDownloadBlockRequest, grpc.ServerStreamingServer[StreamFileBlockData]) error {
	return status.Errorf(codes.Unimplemented, "method FileDownloadBlock not implemented")
}
func (UnimplementedStreamAPIServer) FileList(context.Context, *StreamFileListRequest) (*StreamFileListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FileList not implemented")
}
func (UnimplementedStreamAPIServer) FileView(context.Context, *StreamFileViewRequest) (*StreamFileViewResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FileView not implemented")
}
func (UnimplementedStreamAPIServer) FileVersions(context.Context, *StreamFileListVersionsRequest) (*StreamFileListVersionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FileVersions not implemented")
}
func (UnimplementedStreamAPIServer) FileDelete(context.Context, *StreamFileDeleteRequest) (*StreamFileDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FileDelete not implemented")
}
func (UnimplementedStreamAPIServer) mustEmbedUnimplementedStreamAPIServer() {}
func (UnimplementedStreamAPIServer) testEmbeddedByValue()                   {}

// UnsafeStreamAPIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StreamAPIServer will
// result in compilation errors.
type UnsafeStreamAPIServer interface {
	mustEmbedUnimplementedStreamAPIServer()
}

func RegisterStreamAPIServer(s grpc.ServiceRegistrar, srv StreamAPIServer) {
	// If the following call pancis, it indicates UnimplementedStreamAPIServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StreamAPI_ServiceDesc, srv)
}

func _StreamAPI_FileUploadCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamFileUploadCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAPIServer).FileUploadCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAPI_FileUploadCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAPIServer).FileUploadCreate(ctx, req.(*StreamFileUploadCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamAPI_FileUploadChunkCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamFileUploadChunkCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAPIServer).FileUploadChunkCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAPI_FileUploadChunkCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAPIServer).FileUploadChunkCreate(ctx, req.(*StreamFileUploadChunkCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamAPI_FileUploadBlock_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StreamAPIServer).FileUploadBlock(&grpc.GenericServerStream[StreamFileBlockData, StreamFileUploadBlockResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StreamAPI_FileUploadBlockServer = grpc.ClientStreamingServer[StreamFileBlockData, StreamFileUploadBlockResponse]

func _StreamAPI_FileUploadCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamFileUploadCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAPIServer).FileUploadCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAPI_FileUploadCommit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAPIServer).FileUploadCommit(ctx, req.(*StreamFileUploadCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamAPI_FileDownloadCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamFileDownloadCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAPIServer).FileDownloadCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAPI_FileDownloadCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAPIServer).FileDownloadCreate(ctx, req.(*StreamFileDownloadCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamAPI_FileDownloadRangeCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamFileDownloadRangeCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAPIServer).FileDownloadRangeCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAPI_FileDownloadRangeCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAPIServer).FileDownloadRangeCreate(ctx, req.(*StreamFileDownloadRangeCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamAPI_FileDownloadChunkCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamFileDownloadChunkCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAPIServer).FileDownloadChunkCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAPI_FileDownloadChunkCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAPIServer).FileDownloadChunkCreate(ctx, req.(*StreamFileDownloadChunkCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamAPI_FileDownloadChunkCreateV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamFileDownloadChunkCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAPIServer).FileDownloadChunkCreateV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAPI_FileDownloadChunkCreateV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAPIServer).FileDownloadChunkCreateV2(ctx, req.(*StreamFileDownloadChunkCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamAPI_FileDownloadBlock_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamFileDownloadBlockRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamAPIServer).FileDownloadBlock(m, &grpc.GenericServerStream[StreamFileDownloadBlockRequest, StreamFileBlockData]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StreamAPI_FileDownloadBlockServer = grpc.ServerStreamingServer[StreamFileBlockData]

func _StreamAPI_FileList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamFileListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAPIServer).FileList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAPI_FileList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAPIServer).FileList(ctx, req.(*StreamFileListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamAPI_FileView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamFileViewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAPIServer).FileView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAPI_FileView_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAPIServer).FileView(ctx, req.(*StreamFileViewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamAPI_FileVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamFileListVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAPIServer).FileVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAPI_FileVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAPIServer).FileVersions(ctx, req.(*StreamFileListVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamAPI_FileDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamFileDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAPIServer).FileDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAPI_FileDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAPIServer).FileDelete(ctx, req.(*StreamFileDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StreamAPI_ServiceDesc is the grpc.ServiceDesc for StreamAPI service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StreamAPI_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nodeapi.StreamAPI",
	HandlerType: (*StreamAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FileUploadCreate",
			Handler:    _StreamAPI_FileUploadCreate_Handler,
		},
		{
			MethodName: "FileUploadChunkCreate",
			Handler:    _StreamAPI_FileUploadChunkCreate_Handler,
		},
		{
			MethodName: "FileUploadCommit",
			Handler:    _StreamAPI_FileUploadCommit_Handler,
		},
		{
			MethodName: "FileDownloadCreate",
			Handler:    _StreamAPI_FileDownloadCreate_Handler,
		},
		{
			MethodName: "FileDownloadRangeCreate",
			Handler:    _StreamAPI_FileDownloadRangeCreate_Handler,
		},
		{
			MethodName: "FileDownloadChunkCreate",
			Handler:    _StreamAPI_FileDownloadChunkCreate_Handler,
		},
		{
			MethodName: "FileDownloadChunkCreateV2",
			Handler:    _StreamAPI_FileDownloadChunkCreateV2_Handler,
		},
		{
			MethodName: "FileList",
			Handler:    _StreamAPI_FileList_Handler,
		},
		{
			MethodName: "FileView",
			Handler:    _StreamAPI_FileView_Handler,
		},
		{
			MethodName: "FileVersions",
			Handler:    _StreamAPI_FileVersions_Handler,
		},
		{
			MethodName: "FileDelete",
			Handler:    _StreamAPI_FileDelete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FileUploadBlock",
			Handler:       _StreamAPI_FileUploadBlock_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "FileDownloadBlock",
			Handler:       _StreamAPI_FileDownloadBlock_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "nodeapi.proto",
}
